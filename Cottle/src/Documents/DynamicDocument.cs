using System.IO;
using System.Linq;
using Cottle.Documents.Dynamic;
using Cottle.Settings;
using Cottle.Stores;

namespace Cottle.Documents
{
    /// <summary>
    ///     Dynamic document compiles template using MSIL generation for better
    ///     performance. Code generated by JIT compiler can be reclaimed by garbage
    ///     collector, but you should use a caching mechanism to avoid re-creating
    ///     too many DynamicDocument instances using the same template source.
    /// </summary>
    public sealed class DynamicDocument : AbstractDocument
    {
        private readonly Function main;

        public DynamicDocument(TextReader reader, ISetting setting)
        {
            var parser = ParserFactory.BuildParser(setting);

            main = new Function(Enumerable.Empty<string>(), parser.Parse(reader));
        }

        public DynamicDocument(TextReader reader) :
            this(reader, DefaultSetting.Instance)
        {
        }

        public DynamicDocument(string template, ISetting setting) :
            this(new StringReader(template), setting)
        {
        }

        public DynamicDocument(string template) :
            this(new StringReader(template), DefaultSetting.Instance)
        {
        }

        public override Value Render(IContext context, TextWriter writer)
        {
            return main.Execute(null, new ContextStore(context), writer);
        }

        public static void Save(TextReader reader, ISetting setting, string assemblyName, string fileName)
        {
            var parser = ParserFactory.BuildParser(setting);

            Function.Save(parser.Parse(reader), setting.Trimmer, assemblyName, fileName);
        }
    }
}