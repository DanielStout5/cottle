using System;
using System.IO;
using System.Linq;
using System.Reflection.Emit;
using Cottle.Documents.Dynamic;
using Cottle.Parsers;
using Cottle.Settings;
using Cottle.Values;

namespace Cottle.Documents
{
	/// <summary>
	/// Dynamic document compiles template using MSIL generation for better
	/// performance. Code generated by JIT compiler can be reclaimed by garbage
	/// collector, but you should use a caching mechanism to avoid re-creating
	/// too many DynamicDocument instances using the same template source.
	/// </summary>
	public sealed class DynamicDocument : AbstractDocument
	{
		#region Attributes

		private readonly Renderer	renderer;

		private readonly string[]	strings;

		private readonly Value[]	values;

		#endregion

		#region Constructors

		public DynamicDocument (TextReader reader, ISetting setting)
		{
			Allocator		allocator;
			ILGenerator		generator;
			DynamicMethod	method;
			IParser			parser;
			Block			root;

			method = new DynamicMethod (string.Empty, typeof (Value), new [] {typeof (string[]), typeof (Value[]), typeof (IScope), typeof (TextWriter)}, this.GetType ());
			parser = new DefaultParser (setting.BlockBegin, setting.BlockContinue, setting.BlockEnd);

			generator = method.GetILGenerator ();
			allocator = new Allocator (generator.DeclareLocal (typeof (Value)));
			root = parser.Parse (reader);

			this.CompileBlock (generator, allocator, setting.Trimmer, root);

			this.renderer = (Renderer)method.CreateDelegate (typeof (Renderer));
			this.strings = allocator.Strings.ToArray ();
			this.values = allocator.Values.ToArray ();
		}

		public DynamicDocument (TextReader reader) :
			this (reader, DefaultSetting.Instance)
		{
		}

		public DynamicDocument (string template, ISetting setting) :
			this (new StringReader (template), setting)
		{
		}

		public DynamicDocument (string template) :
			this (new StringReader (template), DefaultSetting.Instance)
		{
		}

		#endregion

		#region Methods / Public

		public override Value Render (IScope scope, TextWriter writer)
		{
			return this.renderer (this.strings, this.values, scope, writer);
		}

		#endregion

		#region Methods / Private

		private void CompileBlock (ILGenerator generator, Allocator allocator, Trimmer trimmer, Block block)
		{
			switch (block.Type)
			{
				case BlockType.AssignFunction:
					// FIXME

					break;

				case BlockType.AssignValue:
					// FIXME

					break;

				case BlockType.Composite:
					this.CompileBlock (generator, allocator, trimmer, block.Body);
					this.CompileBlock (generator, allocator, trimmer, block.Next);

					break;

				case BlockType.Dump:
					generator.Emit (OpCodes.Ldarg_3);

					this.CompileExpression (generator, allocator, block.Source);
					this.EmitCallWriteObject (generator);

					break;

				case BlockType.Echo:
					generator.Emit (OpCodes.Ldarg_3);

					this.CompileExpression (generator, allocator, block.Source);
					this.EmitCallValueAsString (generator);
					this.EmitCallWriteString (generator);

					break;

				case BlockType.For:
					// FIXME

					break;

				case BlockType.Literal:
					generator.Emit (OpCodes.Ldarg_3);

					this.EmitString (generator, allocator, trimmer (block.Text));
					this.EmitCallWriteString (generator);

					break;

				case BlockType.Return:
					// FIXME

					break;

				case BlockType.Test:
					// FIXME

					break;

				case BlockType.While:
					// FIXME

					break;
			}

			generator.Emit (OpCodes.Ldnull);
			generator.Emit (OpCodes.Ret);
		}

		private void CompileExpression (ILGenerator generator, Allocator allocator, Expression expression)
		{
			Label	success;

			switch (expression.Type)
			{
				case ExpressionType.Access:
					success = generator.DefineLabel ();

					this.CompileExpression (generator, allocator, expression.Source);

					generator.Emit (OpCodes.Callvirt, Resolver.Property<Func<Value, IMap>> ((value) => value.Fields).GetGetMethod ());

					this.CompileExpression (generator, allocator, expression.Subscript);

					generator.Emit (OpCodes.Ldloca_S, allocator.LocalValue);
					generator.Emit (OpCodes.Callvirt, typeof (IMap).GetMethod ("TryGet"));
					generator.Emit (OpCodes.Brtrue, success);

					this.EmitVoid (generator);

					generator.Emit (OpCodes.Stloc_S, allocator.LocalValue);

					generator.MarkLabel (success);
					generator.Emit (OpCodes.Ldloc_S, allocator.LocalValue);

					break;

				case ExpressionType.Invoke:
					// FIXME

					break;

				case ExpressionType.Map:
					// FIXME

					break;

				case ExpressionType.Name:
					success = generator.DefineLabel ();
		
					generator.Emit (OpCodes.Ldarg_2);
		
					this.EmitValue (generator, allocator, expression.String);
		
					generator.Emit (OpCodes.Ldloca_S, allocator.LocalValue);
					generator.Emit (OpCodes.Callvirt, typeof (IScope).GetMethod ("Get"));
					generator.Emit (OpCodes.Brtrue, success);
		
					this.EmitVoid (generator);
		
					generator.Emit (OpCodes.Stloc_S, allocator.LocalValue);
		
					generator.MarkLabel (success);
					generator.Emit (OpCodes.Ldloc_S, allocator.LocalValue);

					break;

				case ExpressionType.Number:
					this.EmitValue (generator, allocator, expression.Number);

					break;

				case ExpressionType.String:
					this.EmitValue (generator, allocator, expression.String);

					break;

				case ExpressionType.Void:
					this.EmitVoid (generator);

					break;
			}
		}

		private void EmitCallValueAsString (ILGenerator generator)
		{
			generator.Emit (OpCodes.Callvirt, Resolver.Property<Func<Value, string>> ((value) => value.AsString).GetGetMethod ());
		}

		private void EmitCallWriteObject (ILGenerator generator)
		{
			generator.Emit (OpCodes.Callvirt, Resolver.Method<Action<TextWriter, object>> ((writer, value) => writer.Write (value)));
		}

		private void EmitCallWriteString (ILGenerator generator)
		{
			generator.Emit (OpCodes.Callvirt, Resolver.Method<Action<TextWriter, string>> ((writer, value) => writer.Write (value)));
		}

		private void EmitString (ILGenerator generator, Allocator allocator, string literal)
		{
			generator.Emit (OpCodes.Ldarg_0);
			generator.Emit (OpCodes.Ldc_I4, allocator.Allocate (literal));
			generator.Emit (OpCodes.Ldelem_Ref);
		}

		private void EmitValue (ILGenerator generator, Allocator allocator, Value constant)
		{
			generator.Emit (OpCodes.Ldarg_1);
			generator.Emit (OpCodes.Ldc_I4, allocator.Allocate (constant));
			generator.Emit (OpCodes.Ldelem_Ref);
		}

		private void EmitVoid (ILGenerator generator)
		{
			generator.Emit (OpCodes.Call, Resolver.Property<Func<Value>> (() => VoidValue.Instance).GetGetMethod ());
		}

		#endregion
	}
}
